모던 자바 인 액션 Part 6
------------------------

#### Chap 18 : 함수형 관점으로 생각하기

-	함수형? 람다, 일급 함수와 관련 있으며 때로는 객체 변화를 제한하는 것이 함수형과 밀접한 관련을 갖는다.
-	함수형을 적용하면 어떤 점이 좋은가? 에 대한 답을 찾는다.

##### 18.1 시스템 구현과 유지보수

-	쉽게 유지보수 할 수 있으려면 ???

	-	프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영하면 좋음
	-	시스템의 각 부분의 상호 의존성을 가리키는 결합성과 시스템의 다양한 부분이 어떤 관계를 갖는지 가리키는 응집성이라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.

-	그러나 많은 프로그래머는 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪음 (에상하지 못한 변숫 값 등)

	-	함수형 프로그래밍이 제공하는 부작용 없음과 불변성이 라는 개념이 이 문제를 해결하는 데 도움을 준다.

-	공유된 가변 데이터

	-	변수가 예상하지 못한 값을 갖는 이유는 결국 유지보수하는 시스템에서 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 떄문임.

	-	공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워짐

	-	자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 부작용 없는 메서드라고 부른다. (아래는 부작용 예시)

		-	자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
		-	예외발생
		-	파일에 쓰기 등의 I/O 동작 수행

	-	부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다.

-	선언형 프로그래밍

	-	프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다.
		-	'어떻게' 수행할 것인지에 집중 (고전적 객체지향프로그래밍에서 이용하는 방식: 할당, 조건문, 분기문, 루프 등- 명령형 프로그래밍)
		-	'무엇을' 집중하는 방법 (질의문 구현 방법은 라이브러리가 결정 -선언형 프로그래밍)

-	왜 함수형 프로그래밍인가?

	-	함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 이전에 설명한 것 처럼 부작용이 없는 계산을 지향한다.
		-	선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.
		-	람다표현식을 이용해서 보여준 것 처럼 작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는 데 많은 도움을 준다. (스트림은 여러 연산을 연결해서 복잡한 질의를 표현할 수 있었다.)

##### 18.2 함수형 프로그래밍이란 무엇인가?

-	함수를 이용하는 프로그래밍...

-	함수형 프로그래밍에서 함수란 수학적인 함수와 같다.

	-	함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 부작용이 없어야한다.
	-	자바와 같은 언어에서는 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심 (인수가 같다면 반복적 호출 시 항상 같은 결과가 반환되야함)
	-	함수형 : 수학의 함수처럼 부작용이 없는 것
	-	함수형 프로그래밍
		-	함수 그리고 if-then-else 등의 수학적 표현만 사용하는 방식
		-	시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용하는 방식

-	함수형 자바

	-	실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 하지만, 시스템의 컴포넌트가 순수한 함수형인 것 처럼 동작하도록 코드를 구현할 수 있다.

		-	자바에서는 순수 함수형이 아니라 함수형 프로그램을 구현
		-	실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있음

	-	함수형 자바는?

		-	함수나 메서드는 지역변수만을 변경해여 함수형이라 할 수 있다.
		-	함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 함. (객체의 모든 필드가 final, 모든 참조 필드는 불변 객체를 직접 참조)
		-	함수나 메서드가 어떤 예외도 일으키지 않아야 한다. (예외가 발생하면 return 으로 객체를 반환할 수 없게 될 수 있음)
		-	함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용를 포함하는 라이브러리 함수를 사용해야 한다. (먼저 자료구조를 복사하든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 함)

-	참조 투명성

	-	'부작용을 감춰야 한다'라는 제약은 참조 투명성 개념으로 귀결된다.

		-	같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표햔한다.
		-	함수는 어떤 입력이 주어졌을 때 언제 어디서 호출하든 같은 결과를 생성해야 한다.

	-	참조 투명성은 프로그램 이해에 큰 도움을 준다.

	-	참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.

##### 18.3 재귀와 반복

-	순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 포함하지 않는다.

	-	이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있음 (부작용발생위험)

-	이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구현할 수 있는데 재귀를 이용하면 변화가 일어나지 않는다.

	-	하지만 일반적으로 반복코드보다 재귀코드가 더 비싸다. (함수를 호출할 때마다 호출 스택에 각 호출 시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어짐. > 메모리 사용량이 증가함)

	-	함수형언어에서는 꼬리 호출 최적화 를 통해 해결한다.

		-	중간 결과를 각각의 스택프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다.

-	결론

	-	자바8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다.
	-	반복을 재귀로 바꾸면 더 간결하고, 부작용이 없는 알고리즘을 만들 수 있다.
	-	재귀를 이용하면 좀 더 쉽게 읽고, 쓰고, 이해할 수 있는 예제를 만들 수 있다.
	-	약간의 실행시간 차이보다는 프로그래머의 효율성이 더 중요할 때도 많다.

---

#### Chap 19 : 함수형 프로그래밍 기법

-	실무에서 적용할 수 있는 실용적 기법에 대해 배운다.
	-	고차원 함수, 커링, 영구 자료구조, 게으른 리스트, 패턴 매칭, 참조 투명성을 이용한 캐싱, 콤비네이터 등

##### 19.1 함수는 모든 곳에 존재한다.

-	함수형 언어 프로그래머는 함수형 프로그래밍이라는 용어를 좀 더 폭넓게 사용한다.

	-	함수를 마치 일반 값처럼 사용해서 인수로 전달하거나, 결과로 반환하거나, 자료구조에 저장할 수 있다.
	-	일반값처럼 취급할 수 있는 함수를 일급함수 라고 한다.

-	**자바 8이 이전 버전과 구별되는 특징 중 하나가 일급함수를 지원한다는 것임**

	-	:: 연산자로 메서드 참조를 만들거나 람다표현식으로 직접 함수 값을 표현해서 메서드를 함수 값으로 사용할 수 있음.

	```java
	Function<String, Integer> strToInt = Integer::parseInt;
	```

-	고차원 함수

	-	고차원함수 : 다음 중 하나 이상의 동작을 수행하는 함수

		-	하나 이상의 함수를 인수로 받음
		-	함수를 결과로 반환

	-	자바 8에서는 함수를 인수로 전달할 수 있을 뿐만 아니라 결과로 반환하고, 지역 변수로 할당하거나, 구조체로 삽입할 수 있으므로 자바8의 함수도 고차원 함수라고 할 수 있음.

	-	고차원 함수나 메서드를 구현할 때 어떤 인수가 전달도리지 알 수 없으므로 인수가 부작용을 포함할 가능성을 염두해 두어야 한다.

		-	인수로 전달된 함수가 어떤 부작용을 포함하게 될지 정확하게 문서화하는 것이 좋다.

-	커링

	-	커링 : x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법

	-	기존의 변환로직을 재활용한다.

	```java
	static DoubleUnaryOperator curriedConverter(double f, double b){
	    return (double x) -> x * f + b;
	}
	...
	DoubleUnaryOperator convertCtoF = curriedConverter(9.0/5, 32);
	DoubleUnaryOperator convertUStoGBP = curriedConverter(0.6, 0);
	...
	double gbp = convertUStoGBP.applyAsDouble(1000);
	```

##### 19.2 영속 자료구조

-	함수형 프로그램에서 사용하는 자료구조를 살펴본다.
-	함수형 메서드에서는 전역 자료구조나 인수로 전달된 구조를 갱신할 수 없다.

	-	자료구조를 바꾼다면 같은 메서드를 두번 호출했을 때 결과가 달라짐 -> 참조투명성 위배, 인수를 결과로 단순하게 매핑할 수 있는 능력이 상실됨.

-	파괴적인 갱신과 함수형

	-	자료구조를 갱신할 때 문제가 발생할 수 있다.

		-	X 에서 Y로 가는 경로의 firstJourney 라는 변수가 있고, Y에서 Z로 가는 secondJourney 라는 변수가 있을 때 둘을 연결 시키는 link 메서드를 호출하면 firstJourney가 secondJourney를 포함하면서 파괴적인 갱신이 일어난다.
			-	이때 link 메서드는 첫번째 자료구조를 변경하는 메서드임.
			-	이러면 firstJourney에 의존하는 코드가 동작하지 않게 됨.

	-	함수형에서는 위의 부작용을 수반하는 메서드를 제한하는 방식으로 문제를 해결한다.

		-	계산 결과를 표현할 자료구조가 필요하면 기존의 자료구조를 갱신하지 않도록 새로운 자료구조를 만들어야 한다.

		```java
		static TrainJourney append(TrainJourney a, TrainJourney b){
		    return a==null ? b : new TrainJourney(a.price, append(a.onward, b));;
		}
		```

-	트리를 사용한 다른 예제

	-	594p 에서는 트리 갱신에 대한 예제가 나와있다. 새로운 Tree를 통해 갱신하되 인수를 이용해서 가능한 한 많은 정보를 공유하는 예제임.

##### 19.3 스트림과 게으른 평가

-	스트림은 데이터 컬렉션을 처리하는 편리한 도구이다.

	-	스트림은 단 한번만 소비할 수 있다는 제약이 있어서 스트림은 재귀적으로 정의할 수 없다.
	-	이와 같은 제약 때문에 어떤 문제가 발생할 것인지 살펴본다.

-	자기 정의 스트림

	-	스트림은 최종연산을 하게 되면 소비를 하게 됨.
	-	게으른 평가를 통해 재귀적으로 스트림을 실행할 수 있다.

		-	스트림에 최종 연산을 적용해서 실제 계산을 해야 하는 상황에서만 실제 연산이 이루어 진다.
		-	스트림에 여러 연산(filter, map, reduce 등)을 적용할 때 이와 같은 특성을 활용할 수 있다.
		-	게으른 특성 때문에 각 연산별로 스트림을 탐색할 필요 없이 한 번에 여러 연산을 처리할 수 있다.

		-	602p 게으른 리스트 예제

-	자료구조의 10퍼센트 미만의 데이터만 활용하는 상황에서는 게으른 실행으로 인한 오버헤드가 더 커질 수 있다.

	-	게으른 자료구조 때문에 효율성이 떨어진다면 전통적인 코드로 구현하자.

##### 19.4 패턴 매칭

-	일반적으로 함수형 프로그래밍을 구분하는 또 하나의 중요한 특징으로 패턴 매칭이 있다.

-	자바에서는 if-then-else 나 switch를 사용할 수 있는데, 자료형이 복잡해지면서 이러한 작업을 처리하는 데 필요한 코드의 양도 증가했다.

	-	패턴 매칭을 사용하면 이러한 불필요한 잡동사니를 줄일 수 있다.

-	방문자 디자인 패턴

	-	자바에서는 방문자 디자인 패턴으로 자료형을 언랩할 수 있다.
	-	특정 데이터 형식을 '방문'하는 알고리즘을 캡슐화하는 클래스를 따로 만들 수 있다.
		-	방문자 클래스는 지정된 데이터 형식의 인스턴스를 입력으로 받는다.
		-	그리고 인스턴스의 모든 멤버에 접근한다.

	```java
	// SimplifyExprVisitor를 인수로 받는 accept를 BinOp에 추가한 다음에 BinOp 자신을 SimplifyExprVisitor로 전달한다.
	class BinOp extends Expr{
	    ...
	    public Expr accept(SimplifyExprVisitor v){
	        return v.visit(this);
	    }
	}


	public class SimplifyExprVisitor {
	    ...
	    public Expr visit(BinOp e){
	        if("+".equals(e.opname) && e.right instanceof Number && ...){
	            return e.left;
	        }
	        return e;
	    }
	}
	```

-	자바로 패턴 매칭 흉내내기

	-	스칼라의 패턴 매칭은 자바보다 뛰어나다. 자바8의 람다를 이용하면 비슷하게 구현가능하다.

	```java
	// 스칼라
	def simplifyExpression(expr: Expr): Expr = expr match{
	    case BinOp("+", e, Number(0)) => e // 0 더하기
	    case BinOp("*", e, Number(1)) => e // 1 곱하기
	    case BinOp("/". e, Number(1)) => e // 1로 나누기
	    case _ => expr
	}


	Expression match { case Pattern => Expression ... }


	// 자바
	public static Expr simplify(Expr e){
	    TriFunction<String, Expr, Expr, Expr> binopcase =
	        (opname, left, right) -> {
	            if("+".equals(opname)){
	                if(left instanceof Number && ((Number) left).val == 0){
	                    return right;
	                }


	                if(right instanceof Number && ((Number) right).val == 0) {
	                    return left;
	                }
	            }


	            if("*".equals(opname)){
	                if(left instanceof Number && ((Number) left).val == 1){
	                    return right;
	                }
	                if(right instanceof Number && ((Number) right).val == 1){
	                    return left;
	                }
	            }
	            return new BinOp(opname, left, right);
	        };


	        Function<Integer, Expr> numcase = val -> new Number(val);
	        Supplier<Expr> defaultclas = () -> new Number(0);


	        return patternMatchExpr(e, binopcase, numcase, defaultcase);
	}
	```

##### 19.5 기타 정보

-	함수형, 참조 투명성의 특성에 관련된 두 가지 세부 주제를 살펴본다.

	-	효율성
	-	같은 결과를 반환하는 것과 관련된 염려사항

-	캐싱 또는 기억화

	-	반복이 필요한 비싼 계산비용의 메서드가 있을 수 있다.
	-	오버헤드를 피하기 위해서 기억화라는 기법을 활용하면 된다. (참조 투명성이 유지되는 상황이라면)

		-	기억화 : 메서드에 래퍼로 캐시(HashMap 같은)를 추가하는 기법
		-	다수의 호출자가 공유하는 자료구조를 갱신하는 기법으로 순수 함수형 해결방식은 아니지만 감싼 버전의 코드는 참조 투명성을 유지할 수 있다.

			-	래퍼가 호출되면 인수, 결과 쌍이 캐시에 존재하는지 먼저 확인한다.
			-	캐시에 값이 존재하면 캐시에 저장된 값을 즉시 반환함.
			-	캐시에 존재하지 않으면 결과를 계산한 다음에 새로운 인수, 결과쌍을 캐시에 저장하고 결과를 반환한다.

	```java
	final Map<Range, Integer> numberOfNodes = new HashMap<>();
	Integer computeNumberOfNodesUsingCache(Range range){
	    Integer result = numberOfNodes.get(range);
	    if(result != null){
	        return result;
	    }
	    result = computeNumberOfNodes(range);
	    numberOfNodes.put(range, result);
	    return result;
	}
	```

-	'같은 객체를 반환함'은 무엇을 의미하는가?

	-	일반적으로 함수형 프로그래밍에서는 데이터가 변경되지 않으므로 같다는 의미는 ==(참조가 같음)이 아니라 구조적인 값이 같다는 것을 의미한다.

-	콤비네이터

	-	함수형 프로그래밍에서는 두 함수를 인수로 받아 다른 함수로 반환하는 등 함수를 조합하는 고차원 함수를 많이 사용하게 된다.
	-	콤비네이터 : 함수를 조합하는 기능
	-	자바8 API에 추가된 많은 기능은 콤비네이터의 영향을 받음.

	```java
	// 함수조합 개념을 보여주는 코드
	static<A,B,C> Function<A,C> compose(Function<B,C> g, Function<A,B> f){
	    return x -> g.apply(f.apply(x));
	}
	```

##### 19.6 마치며

-	일급 함수란 인수로 전달하거나, 결과를 반환하거나, 자료구조에 저장할 수 있는 함수
-	고차원 함수란 한 개 이상의 함수를 인수로 받아서 다른 함수를 반환하는 함수.

	-	자바에서는 comparing, andThen, compose 등의 고차원 함수 제공

-	커링은 함수를 모듈화하고 코드를 재사용할 수 있도록 지원하는 기법

-	영속 자료구조는 갱신될 때 기존 버전의 자신을 보존함.

	-	결과적으로 자신을 복사하는 과정이 따로 필요하지 않음.

-	자바의 스트림은 스스로 정의할 수 없음

-	게으른 리스트는 자바 스트림보다 비싼 버전으로 간주할 수 있음.

	-	게으른 리스트는 데이터를 요청했을 때 Supplier을 이용해서 요소를 생성함.
	-	Supplier는 자료구조의 요소를 생성하는 역할을 수행함.

-	패턴 매칭은 자료형을 언랩하는 함수형 기능임.

	-	자바의 switch문을 일반화할 수 있음

-	참조 투명성을 유지하는 상황에서는 계산 결과를 캐시할 수 있음

-	콤비네이터는 둘 이상의 함수나 자료구조를 조합하는 함수형 개념임

---

#### Chap 20 : OOP와 FP의 조화 - 자바와 스칼라 비교

-	스칼라는 객체지향과 함수형 프로그래밍을 혼합한 언어다.

	-	보통 정적 형식의 프로그래밍 언어로 함수형의 기능을 수행하면서도 JVM에서 수행되는 언어이므로 자바 느낌을 원하는 프로그래머가 찾는다.
	-	스칼라는 자바에 비해 많은 기능을 제공함.
		-	복잡한 형식 시스템, 형식추론, 패턴 미칭, 도메인 전용 언어를 단순하게 정의할 수 있는 구조 등을 제공
		-	스칼라 코드에서는 모든 자바 라이브러리를 사용할 수 있음.

-	스칼라와 자바에 적용된 함수형 기능을 살펴보면서 자바의 한계가 무엇인지 확인할 수 있는 시간이 될 것임.

##### 20.1 스칼라 소개

-	스칼라의 특성을 살펴볼 수 있는 간단한 스칼라 프로그램을 소개한다.

-	명령형 스칼라

	-	자바에서는 클래스 내에서 main메서드를 선언하지만 스칼라에서는 object로 직접 싱글턴 객체를 만들 수 있다.

		-	예제에서는 object로 Beer 클래스를 정의하고 동시에 인스턴화했음 (한 번에 단 하나의 인스턴스만 생성됨)

	```java
	/*
	다음을 출력한다.
	Hello 2 bottles of beer
	Hello 3 bottles of beer
	...
	Hello 6 bottles of beer
	*/
	object Beer{
	    def main(args: Array[String]){
	        var n : Int = 2
	        while( n <= 6 ){
	            println(s"Hello ${n} bottles of beer")
	            n += 1
	        }
	    }
	}
	```

-	함수형 스칼라

	-	자바와 달리 스칼라에는 기본형이 없다. (모든 것이 객체임)
	-	람다 표현식은 자바와 비슷함 ( => 를 사용함)
	-	아래는 처음 예제의 while 루프처럼 변수를 갱신하지 않으므로 함수형 예제임

	```java
	object Beer{
	    def main(args: Array[String]){
	        2 to 6 foreach { n => println(s"Hello ${n} bottles of beer")}
	    }
	}
	```

-	기본 자료구조 : 리스트, 집합, 맵, 튜플, 스트림, 옵션

	-	컬렉션 만들기
		-	스칼라는 -> 라는 문법으로 키를 값에 대응시켜 맵을 만들 수 있다.
		-	authorsToAge 의 형식을 지정하지 않아도 스칼라는 자동으로 변수형을 추론하는 기능이 있음 (모든 변수의 형식은 컴파일할 때 결정된다.)
		-	var 대신 val을 사용하였는데, val는 변수가 읽기 전용(변수에 값을 할당할 수 없음. 자바의 final) var는 읽고 쓸 수 있는 변수를 가리킨다.

	```java
	val authorsToAge = Map("Raoul" -> 23, "Mario" -> 40, "Alan" -> 50)
	```

	-	불변과 가변

		-	컬렉션은 기본적으로 불변이다.
		-	스칼라의 불변 컬렉션을 갱신해야 할 때는 어떻게 할까?
			-	기존 버전과 가능한 한 많은 자료를 공유하는 새로운 컬렉션을 만드는 방법으로 자료구조를 갱신한다. (암묵적인 데이터 의존성을 줄일 수 있음-언제 어디서 컬렉션을 갱신했는지 크게 신경쓰지 않아도 됨)

		```java
		val numbers = Set(2,5,3);
		val newNumbers = numbers + 8;


		println(newNumbers); // 2,5,3,8
		println(numbers); // 2,5,3
		```

	-	컬렉션 사용하기

		-	스칼라의 컬렉션 동작은 스트림 API와 비슷함

		```java
		val fileLines = Source.fromFile("data.txt").getLines.toList()
		val linesLongUpper = fileLines.filter(l => l.length() > 10)
		                                            .map(l => l.toUpperCase())


		// 또는 이렇게 구현가능
		// _.length() 는 l=l.length() 로 해석 가능
		val linesLongUpper = fileLines filter (_.length() > 10) map(_.toUpperCase())


		// 병렬실행
		val linesLongUpper = fileLines.par filter (_.length() > 10 ) map(_.toUpperCase())                  
		```

	-	튜플

		-	자바는 튜플을 지원하지 않는다. 직접 자료구조를 만들어야함. (이것도 유연하지 않아 프로그램의 가독성과 유지보수성을 떨어뜨림)
		-	스칼라는 튜플 축약어 를 통해 만들 수 있는 기능을 제공함

		```java
		val book = (2018 "Modern Java in Action", "Manning")


		// _1, _2 등의 접근자로 튜플의 요소에 접근가능
		println(book._1)
		```

	-	스트림

		-	자바의 스트림은 요청할 때만 평가된다(게으른 평가). 메모리 오버플로 없이 무한 스퀀스를 표한할 수 있다.
		-	스칼라에서도 스트림이라는 게으르게 평가되는 자료구조를 제공함. (자바보다 다양한 기능을 제공함)

			-	스칼라의 스트림은 이전 요소가 접근할 수 있도록 기존 계산 값을 기억함
			-	인덱스를 제공함 (리스트처럼 인덱스로 스트림의 요소에 접근가능함)

		-	이러한 기능이 추가되면서 스칼라의 스트림은 자바의 스트림에 비해 메모리 효율성이 조금 떨어짐

	-	옵션

		-	스칼라는 자바의 Optional 과 같은 기능을 제공하는 옵션이라는 자료구조도 있음

		```java
		def getCarInsuranceName(person: Option[Person], minAge: Int) =
		    person.filter(_.getAge() >= minAge)
		                    .flatMap(_.getCar)
		                    .flatMap(_.getInsurance)
		                    .map(_.getName)
		                    .getOrElse("Unknown")
		```

##### 20.2 함수

-	스칼라의 함수는 어떤 작업을 수행하는 일련의 명령어 그룹임.

-	스칼라의 일급 함수

	-	스칼라의 함수는 일급 값이다. (Integer나 String 처럼 함수를 인수로 전달하거나, 결과로 반환하거나, 변수에 저장할 수 있다. 자바의 메서드참조와 메서드 참조도 일급함수)

-	익명 함수와 클로저

	-	스칼라도 익명 함수의 개념을 지원함

	-	자바가 람다표현식을 사용할 수 있도록 Predicate, Function, Consumer 등의 내장 함수형 인터페이스를 제공한다.

		-	마찬가지로 스칼라는 트레이트를 지원함

	-	클로저 : 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스를 가리킴

		-	자바의 람다표현식에는 람다가 정의한 메서드의 지역변수를 고칠 수 없다는 제약이 있음. (이들 변수는 암시적으로 final로 표시됨. 람다는 변수가 아닌 값을 닫는다)
		-	스칼라의 익명함수는 값이 아니라 변수를 캡처할 수 있다.
		-	클로저는 꼭 필요할 때만 사용.. (프로그램을 쉽게 유지보수하고 병렬화하려면)

-	커링

	-	여러 인수를 받는 함수를 인수의 일부를 받는 여러함수로 분할할 수 있다.
	-	스칼라에서는 기존 함수를 쉽게 커리할 수 있는 방법 제공

##### 20.3 클래스와 트레이트

-	스칼라의 클래스와 인터페이스는 자바에 비해 더 유연함을 제공한다.

-	간결성을 제공하는 스칼라의 클래스

	-	스칼라는 완전한 객체지향 언어이므로 클래스를 만들고 객체로 인스턴스화할 수 있다.

	-	게터와 세터

		-	스칼라에서는 생성자, 게터, 세터가 암시적으로 생성된다!

		```python
		class Student(var name: String, var id: Int)
		val s = new Student("Raoul", 1)
		println(s.name)
		s.id = 1337
		println(s.id)
		```

-	스칼라 트레이트와 자바 인터페이스

	-	스칼라는 트레이트라는 유용한 추상 기능도 제공한다. (트레이트는 자바의 인터페이스를 대체한다)
	-	트레이트로 추상 메서드와 기본 구현을 가진 메서드 두 가지를 모두 정의할 수 있다.
	-	트레이트는 다중상속을 지원함. (인터페이스와 디폴트 메서드 기능이 합쳐진 것으로 이해할 수 있음)
	-	인터페이스와는 달리 객체 트레이트는 인스턴스화 과정에서도 조합할 수 있음

#### Chap 21 : 결론 그리고 자바의 미래

##### 21.1 자바 8의 기능 리뷰

-	자바 8에 큰 변화가 생긴 이유

	-	1.멀티코어 프로세서의 파워를 충분히 활용하기 위해
	-	2.간결하게 데이터 컬렉션을 다루는 추세임(간결하게 처리하려면 불변 값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요함)

	-	필드를 변화하고 반복자를 적용하는 기존의 객체지향, 명령형 언어로는 이러한 추세를 만족시키기 어렵다.

		-	한 코어에서 데이터를 변화시키고 다른 코어에서 이 데이터를 읽으려면 비싼 비용을 치러야할 뿐 아니라 잠금 관련 버그도 많이 발생한다.

	-	하지만 함수형 프로그래밍을 사용하면 이 두가지 추세를 모두 달성할 수 있음.

-	동작 파라미터화(람다와 메서드 참조)

	-	재사용할 수 있는 filter 같은 메서드를 구현하려면 filter 메서드의 인수가 필터링 조건을 받도록 만들어야 한다.

		-	기존자바로 구현하려면 상당히 복잡하고 유지보수하는 것도 쉽지 않아진다.
		-	함수형 프로그래밍에서 지원하는 메서드로 코드 블록을 전달하는 기법을 자바 8에서도 제공함
		-	메서드로 전달되는 값은 Function<T, R>, Predicate<T>, BiFunction<T,U,R> 등의 형식을 가지며 메서드를 수신한 코드에서는 apply, test 등의 메서드로 코드를 실행할 수 있음.

-	스트림

	-	자바의 컬렉션 클래스, 반복자, for-each 구문은 오랫동안 사용된 기능이다.

		-	자바8 설계자는 기존 컬렉션에 람다를 활용한 방안보다 새로운 스트림 API를 만드는 방법을 선택했다.

	-	컬렉션과 스트림을 비슷한 점과 다른점

		-	컬렉션에 세 가지 연산을 적용하려면 컬렉션을 세 번 탐색해야 함 (스트림은 게으른 형식의 연산으로 한번의 탐색으로 파이프라인의 모든 연산을 수행함)
		-	스트림이 큰 데이터 집합일 수록 데이터 처리 방시이 효율적이며, 메모리 캐시 등의 관점에서도 커다란 데이터 집합일수록 탐색 횟수를 최소화하는 것이 중요함
		-	또한 멀티코어 CPU를 활용해서 병렬로 요소를 처리하는 기능도 매우 중요 (스트림의 parallel 메서드)

-	CompletableFuture 클래스

	-	자바 5부터 Future 인터페이스 제공

		-	Future를 이용하면 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어로 작업을 할당할 수 있음 (멀티코어를 잘 활용할 수 있음)
		-	다른 작업을 생성한 기존 작업에서 결과가 필요할 때는 get메서드를 호출해서 생성된 Future가 완료될때 까지 기다릴 수 있다.

	-	16장에서는 Future를 구현하는 CompletableFuture 자바 8의 클래스를 소개하였음

		-	'CompletableFuture 와 Future의 관계는 스트림과 컬렉션의 관계와 같다'
			-	스트림에서는 파이프라인 연산을 구성할 수 있으므로 map, filter 등으로 동작파라미터화를 제공한다. 따라서 반복자를 활용했을 때 생기는 불필요한 코드를 피할 수 있다.
			-	CompletableFuture는 Future와 관련한 공통 디자인 패턴을 함수형 프로그래밍으로 간결하게 표현할 수 있도록 thenCompose, thenCombine, allOf 등을 제공한다. (명령형에서 발생하는 불필요한 코드를 피할 수 있음)

-	Optional 클래스

	-	자바8 라이브러리는 T형식의 값을 반환하거나 아니면 값이 없음을 의미하는 Optional.empty라는 정적 메서드를 반환할 수 있는 Optional<T> 클래스를 제공한다.

		-	에러가 잘 발생할 수 있는 계산을 수행하면서 값이 없을 때 에러를 발생시킬 수 있는 null 대신 정해진 데이터 형식을 제공할 수 있다.

		-	Optional<T> 클래스는 map, filter, ifPresent를 제공한다.

			-	계산을 연결할 때 함수형으로 map, filter, ifPresent 등을 사용할 수 있으며, 값이 없는 상황을 사용자 코드에서 확인하는 것이 아니라 라이브러리에서 확인할 수 있다.

		-	자바9에서는 Optional API에 stream(), or(), ifPresentOrElse() 등의 새로운 메서드가 추가됐다.

-	Flow API

	-	자바 9에서는 리액티브 스트림과 당김 기반 역압력 프로토콜을 표준화했다.
	-	Flow API는 호환선을 높일 수 있도록 라이브러리가 구현할 수 있는 네 개의 인터페이스 Publisher, Subscriber, Subscription, Processor를 포함한다.

-	디폴트 메서드

	-	자바8 이전에는 인터페이스에 메서드 시그니처만 정의했다.
	-	하지만 디폴트 메서드 덕분에 인터페이스 설계자는 기본 구현을 제공할 수 있다.
	-	특히 인터페이스에 새로운 기능을 추가했을 때 기존의 인터페이스를 구현하는 클래스들이 새로 추가된 기능을 구현하지 않을 수 있게 되었다는 점에서 디폴트 메서드는 아주 훌륭한 도구이다. (인터페이스가 바뀌어도 사용자는 신경쓸 필요 없다.)

##### 21.2 자바 9 모듈 시스템

-	자바 9에서는 새 언어 기능은 추가되지 않았지만 스트림의 takeWhile, dropWhile, CompletableFuture의 completeOnTimeout 등 자바 8에서 시작된 여러 기능을 강화했다.

-	자바 9의 핵심은 새 모듈 시스템이다.

	-	module-info.java 파일추가됨
	-	모듈 시스템 덕분에 아키텍처 관점에서 애플리케이션을 설계하고 구현하는 방식이 바뀌었고 하위 부분간 경계와 상호작업 방법 정의가 명확해졌다.  

-	자바의 가시적 접근자는 메서드와 클래스 간의 캡슐화를 정의하는 용도일 뿐 패키지 간에는 모든 접근성이 공개된다.

	-	이런 제약때문에 시스템 속성을 모듈화하는 것이 어려웠다.
	-	특히 어떤 모듈은 공개하고, 어떤 세부 구현은 다른 모듈이나 애플리케이션이 접근할 수 없게 숨겨야 할지 지정할 수 없었다.

-	모듈 시스템 없이는 같은 환경에서 실행되는 모든 코드의 보완관 관련된 기능을 노출하는 것을 막을 방법이 없었다.

	-	악의적인 코드가 모듈의 핵심 부분에 접근가능

-	새로운 자바 모듈 시스템 덕분에 자바 런타임이 작은 런타임을 나눠질 수 있게 되었으므로 애플리케이션에서 필요한 부분만 사용할 수 있다.

	-	모듈 시스템 덕분에 사물인터넷 애플리케이션이나 클라우드에서 자바 런타임을 사용할 수 있다.

-	자바 모듈시스템이 제공하는 장점

	-	안정적 설정 : 모듈 요구사항을 명시적을 선언함으로 의존성 빠짐, 충돌, 순환 등의 문제를 런타임이 아니라 빌드 과정에서 일찍 확인할 수 있다.
	-	강한 캡슐화 : 자바 모듈시스템은 특정 패키지만 노출한 다음 각 모듈에서 공개할 부분과 내부 구현의 영역 접근을 분리할 수 있다.
	-	보안성 개선 : 사용자 모듈의 특정 부분을 사용할 수 없도록 함으로 해커가 보안 제어를 뚫기가 어려워졌다.
	-	성능 개선 : 클래스가 런타임이 로드된 다른 클래스를 참조하는 상황보다는 적은 수의 컴포넌트를 참조할 때 최적화 기술이 더 효과를 발휘한다.
	-	확장성 : 자바 모듈 시스템은 자바 SE 플랫폼을 작은 부분으로 나눔으로 실행중인 애플리케이션에서 필요한 부분만 사용할 수 있다.

##### 21.3 자바 10 지역 변수형 추론

-	자바에서는 기본적으로 변수가 메서드를 정의할 때 다음처럼 형식을 지정해야 한다.

	-	double covertUSDToGBP(double money) { ExchangeRage e = ...;}

-	시간이 지나면서 이와 같은 엄격한 형식 지정이 조금 느슨해졌다.

	-	Map<String, List<String>> myMap = new HashMap<>();
	-	Function<Integer, Boolean> p = x -> booleanExpression;

-	형식이 생력되면 컴파일러가 생략된 형식을 추론한다.

	-	한 개의 식별자로 구성된 형식에 형식 추론을 사용하면 다양한 장점이 생긴다.

		-	한 형식을 다른 형식으로 교체할 때 편집 작업이 줄어든다.

-	스칼라와 C# 언어는 지역변수의 형식은 var 키워드로 대체할 수 있다.(컴파일러가 추론함) 이를 지역 변수형 추론이라 부르며 자바10에 추가되었다.

	-	하지만 지역 변수형 추론과정에서 몇 가지 문제가 발생할 수 있다.
	-	Vehicle을 상속하는 Car가 있을 경우 var x = new Car(); 를 하였을떄 x는 Car인가 Vehicle인가
		-	변수의 형식은 초기화의 형식과 같다고 간주할 수 있음
		-	또한 초기화 코드가 없을 때는 var를 사용할 수 없다는 제약이 있으니 큰 문제가 없다. (초깃값이 없을떄는 사용할 수 없음)

##### 21.4 자바의 미래

-	여기선 좋은 제안임에도 불구하고 기존 성능과의 상호 작용이나 기타 문제 때문에 자바에 채택되지 못한 이유를 설명하고 있다.

---

#### 부록 A 기타 언어 업데이트

##### A.1 어노테이션

-	자바8 의 어노테이션은 두 가지가 개선되었다.

	-	어노테이션을 반복할 수 있다.
	-	모든 형식에 어노테이션을 사용할 수 있다. (자바 8 이전에는 선언에만 어노테이션 사용가능)

-	자바의 어노테이션은 부가 정보를 프로그램에 장식할 수 있는 기능임.

	-	자바 8 이전에는 선언에만 어노테이션을 사용할 수 있었음
	-	즉, 어노테이션은 문법적 메타데이터

-	어노테이션 용도

	-	Junit의 콘텍스트에서 어노테이션으로 설정 작업을 하는 메서드와 단위 메서드를 실행하는 메서드를 구분할 수 있음
	-	문서화에 어노테이션 사용가능 (@Deprecated)
	-	자바 컴파일러도 어노테이션을 사용해서 에러를 검출하고, 경로를 줄이고, 코드를 생성할 수 있다.
	-	자바 EE 에서 엔터프라이즈 애플리케이션을 설정할 때 어노테이션을 많이 사용함

-	어노테이션 반복

	-	이전 자바에서는 선언에서 지정한 하나의 어노테이션만 허용했음

		-	반복하고 싶을 땐 배열을 사용했음 ( @Authors( { @Author(name="Raoul"), @Author(name="Mario") } ) ) ---

	-	코드가 복잡해지므로 자바8에서는 반복어노테이션과 관련한 제한을 해제함

		-	어노테이션 반복은 기본으로 제공하는 기능이 아니므로 반복할 수 있는 어노테이션임을 명시적으로 지정해야함

	-	반복할 수 있는 어노테이션 만들기

		-	1. 어노테이션을 @Repeatable 로 표시
		-	2. 컨테이너 어노테이션 제공

		```java
		@Repeatable(Author.class)
		@interface Author{ String name(); }
		@interface Author{ Author[] value [];}
		...
		@Author(name="Raoul") @Author(name="Mario")
		class Book{ }
		```

-	형식 어노테이션

	-	자바 8에서는 모든 형식에 어노테이션을 적용할 수 있다.

		-	new 연산자, instanceof, 형식 캐스트, 제네릭 형식 인수, implements, throws 등에 가능
		-	List<@NonNull Car> cars = new ArrayList<>();

	-	형식 어노테이션은 프로그램을 분석할 때 유용함 (코드를 실행하면서 예상하지 못한 에러 발생 가능성을 줄일 수 있음)

##### A.2 일반화된 대상 형식 추론

-	자바8은 인수 추론 기능을 개선했다.

```java
// 자바 8 이전에도 콘텍스트 정보를 이용한 형식 추론은 지원했었음
static<T> List<T> emptyList();

// 메서드를 호출할 때 명시적으로 형식을 사용해서 형식 파라미터의 형식을 지정할 수 있음
List<Car> cars = Collections.<Car>emptyList();

// 제네릭 인수 추론
List<Car> cars = Collections.emptyList();

// 하지만 자바 8 이전까지는 콘텍스트에 의한 추론이 실행되어 아래 코드는 사용할 수 없었음
static void cleanCar(List<Car> cars){

}
cleanCars(Collections.emptyList());

// 자바8에서는 대상 형식이 메서드 인수에도 적용되므로 명시적인 제네릭 인수를 제공하지 않아도 됨
// Collectors.<Car>toList 대신 Collectors.toList() 사용 가능
List<Car> cleanCars = dirtyCars.stream().filter(Car::isClean).collect(Collectors.toList());
```

---
