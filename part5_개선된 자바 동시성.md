모던 자바 인 액션 Part 5
------------------------

#### Chap 15 : CompletableFuture 와 리액티프 프로그래밍 컨셉의 기초

-	최근 소프퉤어 개발 방법을 획기적으로 뒤집는 두 가지 추세가 있다.

	-	멀티코어 프로세서가 발전하면서 애플리케이션의 속도는 멀티코어 프로세서를 얼마나 잘 활용할 수 있도록 소프트웨어를 개발하는가에 따라 달라짐.

	-	인터넷 서비스에서 사용하는 애플리케이션이 증가하고 있는 현상 (ex_ 마이크로서비스)

		-	앞으로 만들 웹 어플리케이션은 다양한 소스의 콘텐츠를 가져와서 사용자가 삶을 풍요롭게 만들도록 합치는 매시업 형태가 될 가능성이 크다.
		-	이 경우 인터넷으로 여러 웹 서비스에 접근해야하는데, 애플리케이션 생산성을 극대화 시켜야함.  
		-	자바는 이런 환경에서 사용할 수 있는 두 가지 주요 도구를 제공함.

			-	Future 인터페이스로 자바 8의 CompletableFuture 구현
			-	자바 9에 추가된 발행 구독 프로토콜에 기반한 리액티브 프로그래밍 개념을 따르는 플로 API

##### 15.1 동시성을 구현하는 자바 지원의 진화

-	자바의 동시 프로그래밍 지원은 변화에 맞춰 진화해왔다.

	-	Runnable과 Thread를 동기화된 클래스와 메서드를 이용해 잠갔다.
	-	자바 5는 좀 더 표현력있는 동시성을 지원하는 특히 스레드 실행과 태스크 제출을 분리하는 ExecutorService 인터페이스, 높은 수준의 결과 즉, Runnable, Thread의 변형을 반환하는 Callable<T> and Future<T>, 제네릭 등을 지원했다.

	-	멀티코어 CPU에서 효과적으로 프로그래밍을 실행할 필요성이 커지면서 이후 자바 버전에서는 개선된 동시성 지원이 추가되었다.

		-	자바 7 : 분할 그리고 정복 알고리즘의 포크/조인 구현을 지원하는 java.util.concurrent.RecursiveTask

		-	자바 8 : 스트림과 새로 추가된 람자 지원에 기반한 병렬 프로세싱, Future 조합하는 기능(동시성 강화)

		-	자바 9 : 명시적으로 분산 비동기 프로그래밍을 지원, 발행-구독 프로토콜 지원

-	스레드와 높은 수준의 추상화

	-	단일 CPU 컴퓨터도 운영체제가 각 사용자에게 프로세스를 할당하여 여러 사용자에게 지원할 수 있다.

		-	운영체제는 사용자들에게 가상 공간을 각각의 프로세스에 제공한다.
		-	운영체제는 주기적으로 번갈아가며 각 프로세스에 CPU를 할당한다.
		-	프로세스는 다시 운영체제에 한 개 이상의 스레드 즉, 본인이 가진 프로세스와 같은 주소 공간을 공유하는 프로세스를 요청함으로 태스크를 동시에 또는 협력적으로 실행할 수 있다.

	-	네 개의 코어를 가진 CPU에서 이론적으로는 프로그램을 네 개의 코어에서 병렬로 실행함으로써 실행 속도를 네 배 까지 향상시킬 수 있다.

	```java
	  /**
	  한 개의 코어 사용
	  */
	  long sum = 0;
	  for(int i = 0; i < 1_000_000; i++){
	    sum += stats[i];
	  }


	  /**
	  여러 스레드 직접 사용
	  */
	  // 첫 스레드
	  long sum0 = 0;
	  for (int i = 0; i < 250_000; i++){
	    sum0 += stats[i];
	  }
	  ...
	  // 네 번째 스레드
	  long sum3 = 0;
	  for(int i = 750_000; i < 1_000_000; i++){
	    sum3 += stats[i];
	  }


	  // 메인프로그램은 네 개의 스레드를 완성하고 자바의 .start() 로 실행한 다음 .join()으로 완료될 때 까지 기다렸가가 다음을 계산
	  sum = sum0 + ... + sum3;


	  /**
	  자바 스트림
	  */
	  // 외부 반복(명시적 루프)대신 내부 반복 사용
	  sum = Arrays.stream(stats).parallel().sum();
	```

	-	병렬 스트림 반복은 명시적으로 스레드를 하는 것에 비해 높은 수준의 개념임.

		-	스트림을 이용해 스레드 사용 패턴을 추상화할 수 있다.
		-	스트림으로 추상화하는 것은 디자인 패턴을 적용하는 것과 비슷하지만 대신 쓸모 없는 코드가 라이브러리 내부로 구현되면서 복잡성도 줄어든다.

	-	추가적인 스레드 추상화를 살펴보기 전 추상화의 기반 개념에 해당하는 자바 5의 ExecutorService 개념과 스레드 풀을 살펴본다.

-	Executor 와 스레드 풀

	-	자바 5는 Executor 프레임워크와 스레드 풀을 통해 스레드의 힘을 높은 수준으로 끌어올리는 즉 자바 프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공했다.

	-	스레드의 문제

		-	자바 스레드는 직접 운영체제 스레드에 접근한다. 운영체제가 지원하는 스레드 수를 초과해 사용하면 자바 애플리케이션이 예상치 못한 방식으로 크레시도리 수 있으므로 기존 스레드가 실행되는 상태에서 계속 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 한다.

	-	스레드 풀 그리고 스레드 풀이 더 좋은 이유

		-	자바 ExecutorService 는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다.

		```java
		// 프로그램은 newFixedThreadPooll 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있다.
		ExecutorService new FixedThreadPoll(int nThreads);
		```

		-	이 메서드는 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장한다.

		-	스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행함. 태스크 실행이 종료되면 이들 스레드를 풀로 반환한다.

		-	하드웨어에 맞는 수의 태스클르 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이 장점 (큐의 크기조정, 거부 정책, 태스크 종류에 따른 우선순위 등 다양한 설정 가능)

		-	프로그래머는 태스크(Runnable 이나 Callable)를 제공하면 스레드가 이를 실행한다.

	-	스레드 풀 그리고 스레드 풀이 나쁜 이유

		-	거의 모든 관점에서 스레드를 직접 사용하는 것보다 스레드 풀을 이용하는 것이 바람직하지만 두 가지 사항을 주의해야 한다.

			-	k 스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며 이전에 태스크 중 하나가 종료되기 전까지는 스레드에 할당하지 않는다. 불필요하게 많은 스레드를 만드는 일을 피할 수 있으므로 보통 이 상황은 아무 문제가 되지 않지만 **잠을 자거나 I/O를 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야 한다. I/O를 기다리는 블록 상황에서 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만 아무 작업도 하지 않게 된다.** (데드락 발생 가능성있음) 블록(자거나 이벤트를 기다리는)할 수 있는 태스크는 스레드 풀에 제출하지 말아야한다. (이를 항상 지킬 수는 없다.)

			-	프로그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다. (풀의 워크 스레드가 만들어진 다음 다른 태스크 제출을 기다리면서 종료되지 않은 상태일 수 있으므로)

-	스레드의 다른 추상화 : 중첩되지 않은 메서드 호출

	-	7장(병렬 스트림 처리와 포크/조인 프레임워크)의 동시성과 다른 동시성

		-	7장 : 한 개의 특별한 속성 즉, 태스크나 스레드가 메서드 호출안에서 시작되면 그 메서드 호출은 변환하지 않고 작업이 끝나기를 기다림. (스레드 생성과 join()이 한 쌍처럼 중첩된 메서드 호출 내에 추가됨 : 엄격한 포크/조인)

		-	15장 : 사용자의 메서드 호출에 의해 스레드가 생성되고 메서드를 벗어나 계속 실행되는 동시성 형태에 초점을 둔다.

	-	비동기 메서드 : 메서드 호출자에 기능을 제공하도록 메서드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드 (다음은 이들 메서드을 사용할 때 따르는 위험성)

		-	스레드 실행은 메서드를 호출한 다음의 코드와 동시에 실행되므로 데이터 경쟁 문제를 일으키지 않도록 주의해야 한다.
		-	기존 실행 중인 스레드가 종료되지 않은 상황에서 자바의 main() 메서드가 반환하면 어떻게 될까? (다음의 두 방법이 있지만 안전하지 않다.)

			-	애플리케이션을 종료하지 못하고 모든 스레드가 실행을 끝낼 때까지 기다린다.
				-	종료를 못한 스레드에 의해 애플리케이션이 크래시될 수 있음
				-	쓰기 I/O 작업을 시도하는 일련의 작업을 중단했을 때 이로 인해 데이터 일관성 파괴 가능성
				-	이 문제들을 피하려면 애플리케이션에서 만든 모든 스레드를 추적하고 애플리케이션을 종료하기 전에 스레드 풀을 포함한 모든 스레드를 종료하는 것이 좋다.
			-	애플리케이션 종료를 방해하는 스레드를 강제종료시키고 애플리케이션을 종료한다.

		-	자바 스레드는 setDaemon() 메서드를 이용해 데몬 또는 비데몬으로 구분할 수 있다. 데몬 스레드는 애플리케이션이 종료될 때 강죠 종료되므로 디스크의 데이터 일관성을 파괴하지 않는 동작을 수행할 때 유용하게 활용할 수 있는 반면, main() 메서드는 모든 비데몬 스레드가 종료될때까지 프로그램을 종료하지 않고 기다린다.

-	스레드에 무엇을 바라는가?

	-	일반적으로 모든 하드웨어 스레드를 활용해 병렬성의 장점을 극대화하도록 프로그램 구조를 만드는 것 즉, 프로그램을 작은 태스크 단위로 구조화하는 것이 목표다. (태스크 변환 비용을 고려해 너무 작은 크기는 아니어야함)

	-	16,17장 에서는 스레드를 조작하는 복잡한 코드를 구현하지 않고 메서드를 호출하는 방법을 살펴본다.

##### 15.2 동기 API와 비동기 API

-	루프 기반의 계산을 제외한 다른 상황에서도 병렬성이 유용할 수 있다.

-	다음과 같은 시그니처를 같은 f,g 두 메서드의 호출을 합하는 예제를 살펴보자

	-	int f(int x);
	-	int g(int x);

	-	이 메서드는 물리적 결과를 반환하므로 동기 API라고 한다.

		-	int y = f(x);
		-	int z = g(x);

	-	f와 g를 실행하는데 오랜 시간이 걸린다고 가정하자.

		-	f와 g가 사로 상호작용하지 않거나, 상호작용을 전혀 신경쓰지 않는다면 f와 g를 별도의 CPU 코어로 실행함으로 f와 g 중 오래 걸리는 작업의 시간으로 합계 구하는 시간을 단축할 수 있다. (별도의 스레드로 f와 g 중 오래 걸리는 작업의 시간으로 합계를 구하는 시간을 단축할 수 있다.)

		-	하지만 코드가 복잡해질 것이다.

			```java
			class ThreadExample {
			    public static void main(String[] args) throws InterruptedException{
			        int x = 1337;
			        Result result = new Result();


			        Thread t1 = new Thread( () -> {result.left = f(x); } );
			        Thread t2 = new Thread( () -> {result.right = g(x); } );


			        t1.start();
			        t2.start();
			        t1.join();
			        t2.join();


			        System.out.prtinln(result.left + result.right);


			    }


			    public static class Result {
			        private int left;
			        private int right;
			    }
			}
			```

		-	Runnable 대신 Future API 인터페이스를 이용해 코드를 더 단순화 시킬 수 있다. (이미 ExecutorService로 스레드 풀을 설정했다고 가정)

			```java
			public class ExecutorServiceExample{
			    public static void main(String[] args) throws ExcutionExceptiopn, InterruptedExcpetion {


			        int x = 1337;


			        ExecutorService executorService = Executors.newFixedThreadPool(2);
			        Future<Integer> y = executorService.submit( () -> f(x));
			        Future<Integer> z = executorService.submit( () -> g(x));


			        System.out.println(y.get() + z.get());


			        executorService.shutdown();


			    }
			}
			```

		-	하지만 위 코드도 명시적인 submit 메서드 호출 같은 불필요한 코드로 오염되었음.

			-	비공기 API 라는 기능으로 API를 바꿔서 해결할 수 있음
			-	Future 을 이용해서 좀 더 개선할 수 있음
			-	자바 8 의 completableFuture로 이들을 조합할 수 있게 됨.

-	Future 형식 API

	-	f,g의 시그니처 변경

		-	Future<Integer> f(int x);
		-	Future<Integer> g(int x);

	-	호출 변경

		-	Future<Integer> y = f(x);
		-	Future<Integer> z = g(x);

-	리액티브 형식 API

	-	두 번째 대안에서 핵심은 f, g의 시그니처를 바꿔서 콜백 형식의 프로그래밍을 이용하는 것임

		-	void f(int x, IntConsumer dealWithResult);

	-	f에 추가 인수로 콜백(람다)를 전달해서 f의 바디에서는 return 문으로 결과를 반환하는 것이 아니라 결과가 준비되면 이를 람다로 호출하는 태스크를 만드는 것 (f는 바디를 실행하면서 태스크를 만든 다음 즉시 반환하므로 코드 형식이 다음처럼 바뀜)

		```java
		public class CallbackStyleExample{
		    public static void main(String[] args){
		        int x = 1337;
		        Result result = new Result();


		        f(x, (int y) -> {
		            result.left = y;
		            System.out.println((result.left + result.right));
		        });


		        f(x, (int z) -> {
		            result.right = z;
		            System.out.println((result.left + result.rigth));
		        });
		    }
		}
		```

	-	하지만, f와 g의 호출 합계를 정확하게 출력하지 않고 상황에 따라 먼저 계산된 결과를 출력함.

		-	락을 사용하지 않으므로 값을 두 번 출력할 수 있을 뿐더라 때로는 +에 제공된 피연산자가 println이 호출되기 전에 업데이트 될 수 있음 (아래는 두 가지 보완 방법)

			-	if-then-else 를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는 지 확인한 다음 println을 호출해 원하는 기능을 수행할 수 있다.
			-	리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도로 설계되었으므로 Future를 이용하는 것이 더 적절함

	-	리액티브 형식의 비동기 API는 자연스럽게 일련의 값(나중에 스트림으로 연결)을, Future 형식의 API는 일회성의 값을 처리하는 데 적합하다.

-	잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주

	-	스레드는 잠들어도 여전히 시스템 자원을 점유한다.
	-	스레드를 단지 몇 개 사용하는 상황에서는 큰 문제가 아니지만 스레드가 많아지고 그중 대부분 잠을 잔다면 문제가 심각해진다.
	-	스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막으므로 자원을 소비한다는 사실을 기억하자
	-	블록동작에서도 마찬가지임

	-	태스크가 실행되면 귀중한 자원을 점유하므로 태스크가 끝나서 자원을 해제하기 전까지 태스크를 계속 실행해야 한다.

		-	태스크를 블록하는 것보다는 다음 작업을 태스크로 제출하고 현재 태스크는 종료하는 것이 바람직한다.

	-	가능하다면 I/O 작업에도 이 원칙을 적용하는 것이 좋음.

		-	읽기 작업을 기다리는 것이 아니라 블록하지 않는 '읽기 시작'메서드를 호출하고 읽기 작업이 끝나면 이를 처리할 다음 태스크를 런타임 라이브러리에 스케쥴하도록 요청하고 종료한다.

-	현실상 확인

	-	새로운 시스템을 설계할 때 시스템을 많고 작은 동시 실행되는 태스크로 설계해서 블록할 수 있는 모든 동작을 비동기 호출로 구현한다면 병렬 하드웨어를 최대한 활용할 수 있다.
	-	하지만, 현실적으로는 '모든 것은 비동기'라는 설계원칙을 어겨야 한다.

-	비동기 API에서 예외는 어떻게 처리하는가?

	-	Future나 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 별도의 스레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의 실행 범위와는 관계가 없는 상황이 된다.

		-	예상치못한 일이 발새앟면 예외를 발생시켜 다른 동작이 실행되어야 한다. 어떻게 이를 실현할 수 있을까?

			-	Future를 구현한 CompletableFuture에서는 런타임 get() 메서드에 예외를 처리할 수 있는 기능을 제공하여 예외에서 회복할 수 있도록 exceptionally() 같은 메서드도 제공한다.
			-	리액티브 형식의 비동기 API에서는 return 대신 기존 콜백이 호출되므로 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야한다.

			```java
			void f(int x, Consumer<Integer> dealWithResult,
			              Consumer<Throwable> dealWithException);
			```

##### 15.3 박스와 채널 모델
